"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeAws_json1_1DeleteTranscriptionJobCommand = exports.deserializeAws_json1_1DeleteMedicalVocabularyCommand = exports.deserializeAws_json1_1DeleteMedicalTranscriptionJobCommand = exports.deserializeAws_json1_1DeleteLanguageModelCommand = exports.deserializeAws_json1_1DeleteCallAnalyticsJobCommand = exports.deserializeAws_json1_1DeleteCallAnalyticsCategoryCommand = exports.deserializeAws_json1_1CreateVocabularyFilterCommand = exports.deserializeAws_json1_1CreateVocabularyCommand = exports.deserializeAws_json1_1CreateMedicalVocabularyCommand = exports.deserializeAws_json1_1CreateLanguageModelCommand = exports.deserializeAws_json1_1CreateCallAnalyticsCategoryCommand = exports.serializeAws_json1_1UpdateVocabularyFilterCommand = exports.serializeAws_json1_1UpdateVocabularyCommand = exports.serializeAws_json1_1UpdateMedicalVocabularyCommand = exports.serializeAws_json1_1UpdateCallAnalyticsCategoryCommand = exports.serializeAws_json1_1UntagResourceCommand = exports.serializeAws_json1_1TagResourceCommand = exports.serializeAws_json1_1StartTranscriptionJobCommand = exports.serializeAws_json1_1StartMedicalTranscriptionJobCommand = exports.serializeAws_json1_1StartCallAnalyticsJobCommand = exports.serializeAws_json1_1ListVocabularyFiltersCommand = exports.serializeAws_json1_1ListVocabulariesCommand = exports.serializeAws_json1_1ListTranscriptionJobsCommand = exports.serializeAws_json1_1ListTagsForResourceCommand = exports.serializeAws_json1_1ListMedicalVocabulariesCommand = exports.serializeAws_json1_1ListMedicalTranscriptionJobsCommand = exports.serializeAws_json1_1ListLanguageModelsCommand = exports.serializeAws_json1_1ListCallAnalyticsJobsCommand = exports.serializeAws_json1_1ListCallAnalyticsCategoriesCommand = exports.serializeAws_json1_1GetVocabularyFilterCommand = exports.serializeAws_json1_1GetVocabularyCommand = exports.serializeAws_json1_1GetTranscriptionJobCommand = exports.serializeAws_json1_1GetMedicalVocabularyCommand = exports.serializeAws_json1_1GetMedicalTranscriptionJobCommand = exports.serializeAws_json1_1GetCallAnalyticsJobCommand = exports.serializeAws_json1_1GetCallAnalyticsCategoryCommand = exports.serializeAws_json1_1DescribeLanguageModelCommand = exports.serializeAws_json1_1DeleteVocabularyFilterCommand = exports.serializeAws_json1_1DeleteVocabularyCommand = exports.serializeAws_json1_1DeleteTranscriptionJobCommand = exports.serializeAws_json1_1DeleteMedicalVocabularyCommand = exports.serializeAws_json1_1DeleteMedicalTranscriptionJobCommand = exports.serializeAws_json1_1DeleteLanguageModelCommand = exports.serializeAws_json1_1DeleteCallAnalyticsJobCommand = exports.serializeAws_json1_1DeleteCallAnalyticsCategoryCommand = exports.serializeAws_json1_1CreateVocabularyFilterCommand = exports.serializeAws_json1_1CreateVocabularyCommand = exports.serializeAws_json1_1CreateMedicalVocabularyCommand = exports.serializeAws_json1_1CreateLanguageModelCommand = exports.serializeAws_json1_1CreateCallAnalyticsCategoryCommand = void 0;
exports.deserializeAws_json1_1UpdateVocabularyFilterCommand = exports.deserializeAws_json1_1UpdateVocabularyCommand = exports.deserializeAws_json1_1UpdateMedicalVocabularyCommand = exports.deserializeAws_json1_1UpdateCallAnalyticsCategoryCommand = exports.deserializeAws_json1_1UntagResourceCommand = exports.deserializeAws_json1_1TagResourceCommand = exports.deserializeAws_json1_1StartTranscriptionJobCommand = exports.deserializeAws_json1_1StartMedicalTranscriptionJobCommand = exports.deserializeAws_json1_1StartCallAnalyticsJobCommand = exports.deserializeAws_json1_1ListVocabularyFiltersCommand = exports.deserializeAws_json1_1ListVocabulariesCommand = exports.deserializeAws_json1_1ListTranscriptionJobsCommand = exports.deserializeAws_json1_1ListTagsForResourceCommand = exports.deserializeAws_json1_1ListMedicalVocabulariesCommand = exports.deserializeAws_json1_1ListMedicalTranscriptionJobsCommand = exports.deserializeAws_json1_1ListLanguageModelsCommand = exports.deserializeAws_json1_1ListCallAnalyticsJobsCommand = exports.deserializeAws_json1_1ListCallAnalyticsCategoriesCommand = exports.deserializeAws_json1_1GetVocabularyFilterCommand = exports.deserializeAws_json1_1GetVocabularyCommand = exports.deserializeAws_json1_1GetTranscriptionJobCommand = exports.deserializeAws_json1_1GetMedicalVocabularyCommand = exports.deserializeAws_json1_1GetMedicalTranscriptionJobCommand = exports.deserializeAws_json1_1GetCallAnalyticsJobCommand = exports.deserializeAws_json1_1GetCallAnalyticsCategoryCommand = exports.deserializeAws_json1_1DescribeLanguageModelCommand = exports.deserializeAws_json1_1DeleteVocabularyFilterCommand = exports.deserializeAws_json1_1DeleteVocabularyCommand = void 0;
const protocol_http_1 = require("@aws-sdk/protocol-http");
const smithy_client_1 = require("@aws-sdk/smithy-client");
const models_0_1 = require("../models/models_0");
const serializeAws_json1_1CreateCallAnalyticsCategoryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.CreateCallAnalyticsCategory",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateCallAnalyticsCategoryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateCallAnalyticsCategoryCommand = serializeAws_json1_1CreateCallAnalyticsCategoryCommand;
const serializeAws_json1_1CreateLanguageModelCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.CreateLanguageModel",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateLanguageModelRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateLanguageModelCommand = serializeAws_json1_1CreateLanguageModelCommand;
const serializeAws_json1_1CreateMedicalVocabularyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.CreateMedicalVocabulary",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateMedicalVocabularyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateMedicalVocabularyCommand = serializeAws_json1_1CreateMedicalVocabularyCommand;
const serializeAws_json1_1CreateVocabularyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.CreateVocabulary",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateVocabularyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateVocabularyCommand = serializeAws_json1_1CreateVocabularyCommand;
const serializeAws_json1_1CreateVocabularyFilterCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.CreateVocabularyFilter",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateVocabularyFilterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateVocabularyFilterCommand = serializeAws_json1_1CreateVocabularyFilterCommand;
const serializeAws_json1_1DeleteCallAnalyticsCategoryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.DeleteCallAnalyticsCategory",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteCallAnalyticsCategoryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteCallAnalyticsCategoryCommand = serializeAws_json1_1DeleteCallAnalyticsCategoryCommand;
const serializeAws_json1_1DeleteCallAnalyticsJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.DeleteCallAnalyticsJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteCallAnalyticsJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteCallAnalyticsJobCommand = serializeAws_json1_1DeleteCallAnalyticsJobCommand;
const serializeAws_json1_1DeleteLanguageModelCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.DeleteLanguageModel",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteLanguageModelRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteLanguageModelCommand = serializeAws_json1_1DeleteLanguageModelCommand;
const serializeAws_json1_1DeleteMedicalTranscriptionJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.DeleteMedicalTranscriptionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteMedicalTranscriptionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteMedicalTranscriptionJobCommand = serializeAws_json1_1DeleteMedicalTranscriptionJobCommand;
const serializeAws_json1_1DeleteMedicalVocabularyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.DeleteMedicalVocabulary",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteMedicalVocabularyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteMedicalVocabularyCommand = serializeAws_json1_1DeleteMedicalVocabularyCommand;
const serializeAws_json1_1DeleteTranscriptionJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.DeleteTranscriptionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteTranscriptionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteTranscriptionJobCommand = serializeAws_json1_1DeleteTranscriptionJobCommand;
const serializeAws_json1_1DeleteVocabularyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.DeleteVocabulary",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteVocabularyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteVocabularyCommand = serializeAws_json1_1DeleteVocabularyCommand;
const serializeAws_json1_1DeleteVocabularyFilterCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.DeleteVocabularyFilter",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteVocabularyFilterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteVocabularyFilterCommand = serializeAws_json1_1DeleteVocabularyFilterCommand;
const serializeAws_json1_1DescribeLanguageModelCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.DescribeLanguageModel",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeLanguageModelRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeLanguageModelCommand = serializeAws_json1_1DescribeLanguageModelCommand;
const serializeAws_json1_1GetCallAnalyticsCategoryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.GetCallAnalyticsCategory",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetCallAnalyticsCategoryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetCallAnalyticsCategoryCommand = serializeAws_json1_1GetCallAnalyticsCategoryCommand;
const serializeAws_json1_1GetCallAnalyticsJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.GetCallAnalyticsJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetCallAnalyticsJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetCallAnalyticsJobCommand = serializeAws_json1_1GetCallAnalyticsJobCommand;
const serializeAws_json1_1GetMedicalTranscriptionJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.GetMedicalTranscriptionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetMedicalTranscriptionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetMedicalTranscriptionJobCommand = serializeAws_json1_1GetMedicalTranscriptionJobCommand;
const serializeAws_json1_1GetMedicalVocabularyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.GetMedicalVocabulary",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetMedicalVocabularyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetMedicalVocabularyCommand = serializeAws_json1_1GetMedicalVocabularyCommand;
const serializeAws_json1_1GetTranscriptionJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.GetTranscriptionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetTranscriptionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetTranscriptionJobCommand = serializeAws_json1_1GetTranscriptionJobCommand;
const serializeAws_json1_1GetVocabularyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.GetVocabulary",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetVocabularyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetVocabularyCommand = serializeAws_json1_1GetVocabularyCommand;
const serializeAws_json1_1GetVocabularyFilterCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.GetVocabularyFilter",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetVocabularyFilterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetVocabularyFilterCommand = serializeAws_json1_1GetVocabularyFilterCommand;
const serializeAws_json1_1ListCallAnalyticsCategoriesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.ListCallAnalyticsCategories",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListCallAnalyticsCategoriesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListCallAnalyticsCategoriesCommand = serializeAws_json1_1ListCallAnalyticsCategoriesCommand;
const serializeAws_json1_1ListCallAnalyticsJobsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.ListCallAnalyticsJobs",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListCallAnalyticsJobsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListCallAnalyticsJobsCommand = serializeAws_json1_1ListCallAnalyticsJobsCommand;
const serializeAws_json1_1ListLanguageModelsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.ListLanguageModels",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListLanguageModelsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListLanguageModelsCommand = serializeAws_json1_1ListLanguageModelsCommand;
const serializeAws_json1_1ListMedicalTranscriptionJobsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.ListMedicalTranscriptionJobs",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListMedicalTranscriptionJobsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListMedicalTranscriptionJobsCommand = serializeAws_json1_1ListMedicalTranscriptionJobsCommand;
const serializeAws_json1_1ListMedicalVocabulariesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.ListMedicalVocabularies",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListMedicalVocabulariesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListMedicalVocabulariesCommand = serializeAws_json1_1ListMedicalVocabulariesCommand;
const serializeAws_json1_1ListTagsForResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.ListTagsForResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListTagsForResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListTagsForResourceCommand = serializeAws_json1_1ListTagsForResourceCommand;
const serializeAws_json1_1ListTranscriptionJobsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.ListTranscriptionJobs",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListTranscriptionJobsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListTranscriptionJobsCommand = serializeAws_json1_1ListTranscriptionJobsCommand;
const serializeAws_json1_1ListVocabulariesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.ListVocabularies",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListVocabulariesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListVocabulariesCommand = serializeAws_json1_1ListVocabulariesCommand;
const serializeAws_json1_1ListVocabularyFiltersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.ListVocabularyFilters",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListVocabularyFiltersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListVocabularyFiltersCommand = serializeAws_json1_1ListVocabularyFiltersCommand;
const serializeAws_json1_1StartCallAnalyticsJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.StartCallAnalyticsJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartCallAnalyticsJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StartCallAnalyticsJobCommand = serializeAws_json1_1StartCallAnalyticsJobCommand;
const serializeAws_json1_1StartMedicalTranscriptionJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.StartMedicalTranscriptionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartMedicalTranscriptionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StartMedicalTranscriptionJobCommand = serializeAws_json1_1StartMedicalTranscriptionJobCommand;
const serializeAws_json1_1StartTranscriptionJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.StartTranscriptionJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartTranscriptionJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StartTranscriptionJobCommand = serializeAws_json1_1StartTranscriptionJobCommand;
const serializeAws_json1_1TagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.TagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1TagResourceCommand = serializeAws_json1_1TagResourceCommand;
const serializeAws_json1_1UntagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.UntagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UntagResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UntagResourceCommand = serializeAws_json1_1UntagResourceCommand;
const serializeAws_json1_1UpdateCallAnalyticsCategoryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.UpdateCallAnalyticsCategory",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateCallAnalyticsCategoryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateCallAnalyticsCategoryCommand = serializeAws_json1_1UpdateCallAnalyticsCategoryCommand;
const serializeAws_json1_1UpdateMedicalVocabularyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.UpdateMedicalVocabulary",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateMedicalVocabularyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateMedicalVocabularyCommand = serializeAws_json1_1UpdateMedicalVocabularyCommand;
const serializeAws_json1_1UpdateVocabularyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.UpdateVocabulary",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateVocabularyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateVocabularyCommand = serializeAws_json1_1UpdateVocabularyCommand;
const serializeAws_json1_1UpdateVocabularyFilterCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Transcribe.UpdateVocabularyFilter",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateVocabularyFilterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateVocabularyFilterCommand = serializeAws_json1_1UpdateVocabularyFilterCommand;
const deserializeAws_json1_1CreateCallAnalyticsCategoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateCallAnalyticsCategoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateCallAnalyticsCategoryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateCallAnalyticsCategoryCommand = deserializeAws_json1_1CreateCallAnalyticsCategoryCommand;
const deserializeAws_json1_1CreateCallAnalyticsCategoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ConflictException":
        case "com.amazonaws.transcribe#ConflictException":
            response = {
                ...(await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1CreateLanguageModelCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateLanguageModelCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateLanguageModelResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateLanguageModelCommand = deserializeAws_json1_1CreateLanguageModelCommand;
const deserializeAws_json1_1CreateLanguageModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ConflictException":
        case "com.amazonaws.transcribe#ConflictException":
            response = {
                ...(await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1CreateMedicalVocabularyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateMedicalVocabularyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateMedicalVocabularyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateMedicalVocabularyCommand = deserializeAws_json1_1CreateMedicalVocabularyCommand;
const deserializeAws_json1_1CreateMedicalVocabularyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ConflictException":
        case "com.amazonaws.transcribe#ConflictException":
            response = {
                ...(await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1CreateVocabularyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateVocabularyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateVocabularyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateVocabularyCommand = deserializeAws_json1_1CreateVocabularyCommand;
const deserializeAws_json1_1CreateVocabularyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ConflictException":
        case "com.amazonaws.transcribe#ConflictException":
            response = {
                ...(await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1CreateVocabularyFilterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateVocabularyFilterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateVocabularyFilterResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateVocabularyFilterCommand = deserializeAws_json1_1CreateVocabularyFilterCommand;
const deserializeAws_json1_1CreateVocabularyFilterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ConflictException":
        case "com.amazonaws.transcribe#ConflictException":
            response = {
                ...(await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1DeleteCallAnalyticsCategoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteCallAnalyticsCategoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteCallAnalyticsCategoryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteCallAnalyticsCategoryCommand = deserializeAws_json1_1DeleteCallAnalyticsCategoryCommand;
const deserializeAws_json1_1DeleteCallAnalyticsCategoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1DeleteCallAnalyticsJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteCallAnalyticsJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteCallAnalyticsJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteCallAnalyticsJobCommand = deserializeAws_json1_1DeleteCallAnalyticsJobCommand;
const deserializeAws_json1_1DeleteCallAnalyticsJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1DeleteLanguageModelCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteLanguageModelCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteLanguageModelCommand = deserializeAws_json1_1DeleteLanguageModelCommand;
const deserializeAws_json1_1DeleteLanguageModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1DeleteMedicalTranscriptionJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteMedicalTranscriptionJobCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteMedicalTranscriptionJobCommand = deserializeAws_json1_1DeleteMedicalTranscriptionJobCommand;
const deserializeAws_json1_1DeleteMedicalTranscriptionJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1DeleteMedicalVocabularyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteMedicalVocabularyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteMedicalVocabularyCommand = deserializeAws_json1_1DeleteMedicalVocabularyCommand;
const deserializeAws_json1_1DeleteMedicalVocabularyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1DeleteTranscriptionJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteTranscriptionJobCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteTranscriptionJobCommand = deserializeAws_json1_1DeleteTranscriptionJobCommand;
const deserializeAws_json1_1DeleteTranscriptionJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1DeleteVocabularyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteVocabularyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteVocabularyCommand = deserializeAws_json1_1DeleteVocabularyCommand;
const deserializeAws_json1_1DeleteVocabularyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1DeleteVocabularyFilterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteVocabularyFilterCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteVocabularyFilterCommand = deserializeAws_json1_1DeleteVocabularyFilterCommand;
const deserializeAws_json1_1DeleteVocabularyFilterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1DescribeLanguageModelCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeLanguageModelCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeLanguageModelResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeLanguageModelCommand = deserializeAws_json1_1DescribeLanguageModelCommand;
const deserializeAws_json1_1DescribeLanguageModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1GetCallAnalyticsCategoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetCallAnalyticsCategoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetCallAnalyticsCategoryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetCallAnalyticsCategoryCommand = deserializeAws_json1_1GetCallAnalyticsCategoryCommand;
const deserializeAws_json1_1GetCallAnalyticsCategoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1GetCallAnalyticsJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetCallAnalyticsJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetCallAnalyticsJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetCallAnalyticsJobCommand = deserializeAws_json1_1GetCallAnalyticsJobCommand;
const deserializeAws_json1_1GetCallAnalyticsJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1GetMedicalTranscriptionJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetMedicalTranscriptionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetMedicalTranscriptionJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetMedicalTranscriptionJobCommand = deserializeAws_json1_1GetMedicalTranscriptionJobCommand;
const deserializeAws_json1_1GetMedicalTranscriptionJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1GetMedicalVocabularyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetMedicalVocabularyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetMedicalVocabularyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetMedicalVocabularyCommand = deserializeAws_json1_1GetMedicalVocabularyCommand;
const deserializeAws_json1_1GetMedicalVocabularyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1GetTranscriptionJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetTranscriptionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetTranscriptionJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetTranscriptionJobCommand = deserializeAws_json1_1GetTranscriptionJobCommand;
const deserializeAws_json1_1GetTranscriptionJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1GetVocabularyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetVocabularyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetVocabularyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetVocabularyCommand = deserializeAws_json1_1GetVocabularyCommand;
const deserializeAws_json1_1GetVocabularyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1GetVocabularyFilterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetVocabularyFilterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetVocabularyFilterResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetVocabularyFilterCommand = deserializeAws_json1_1GetVocabularyFilterCommand;
const deserializeAws_json1_1GetVocabularyFilterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1ListCallAnalyticsCategoriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListCallAnalyticsCategoriesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListCallAnalyticsCategoriesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListCallAnalyticsCategoriesCommand = deserializeAws_json1_1ListCallAnalyticsCategoriesCommand;
const deserializeAws_json1_1ListCallAnalyticsCategoriesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1ListCallAnalyticsJobsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListCallAnalyticsJobsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListCallAnalyticsJobsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListCallAnalyticsJobsCommand = deserializeAws_json1_1ListCallAnalyticsJobsCommand;
const deserializeAws_json1_1ListCallAnalyticsJobsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1ListLanguageModelsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListLanguageModelsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListLanguageModelsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListLanguageModelsCommand = deserializeAws_json1_1ListLanguageModelsCommand;
const deserializeAws_json1_1ListLanguageModelsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1ListMedicalTranscriptionJobsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListMedicalTranscriptionJobsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListMedicalTranscriptionJobsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListMedicalTranscriptionJobsCommand = deserializeAws_json1_1ListMedicalTranscriptionJobsCommand;
const deserializeAws_json1_1ListMedicalTranscriptionJobsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1ListMedicalVocabulariesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListMedicalVocabulariesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListMedicalVocabulariesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListMedicalVocabulariesCommand = deserializeAws_json1_1ListMedicalVocabulariesCommand;
const deserializeAws_json1_1ListMedicalVocabulariesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListTagsForResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListTagsForResourceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListTagsForResourceCommand = deserializeAws_json1_1ListTagsForResourceCommand;
const deserializeAws_json1_1ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1ListTranscriptionJobsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListTranscriptionJobsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListTranscriptionJobsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListTranscriptionJobsCommand = deserializeAws_json1_1ListTranscriptionJobsCommand;
const deserializeAws_json1_1ListTranscriptionJobsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1ListVocabulariesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListVocabulariesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListVocabulariesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListVocabulariesCommand = deserializeAws_json1_1ListVocabulariesCommand;
const deserializeAws_json1_1ListVocabulariesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1ListVocabularyFiltersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListVocabularyFiltersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListVocabularyFiltersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListVocabularyFiltersCommand = deserializeAws_json1_1ListVocabularyFiltersCommand;
const deserializeAws_json1_1ListVocabularyFiltersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1StartCallAnalyticsJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartCallAnalyticsJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartCallAnalyticsJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1StartCallAnalyticsJobCommand = deserializeAws_json1_1StartCallAnalyticsJobCommand;
const deserializeAws_json1_1StartCallAnalyticsJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ConflictException":
        case "com.amazonaws.transcribe#ConflictException":
            response = {
                ...(await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1StartMedicalTranscriptionJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartMedicalTranscriptionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartMedicalTranscriptionJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1StartMedicalTranscriptionJobCommand = deserializeAws_json1_1StartMedicalTranscriptionJobCommand;
const deserializeAws_json1_1StartMedicalTranscriptionJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ConflictException":
        case "com.amazonaws.transcribe#ConflictException":
            response = {
                ...(await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1StartTranscriptionJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartTranscriptionJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartTranscriptionJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1StartTranscriptionJobCommand = deserializeAws_json1_1StartTranscriptionJobCommand;
const deserializeAws_json1_1StartTranscriptionJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ConflictException":
        case "com.amazonaws.transcribe#ConflictException":
            response = {
                ...(await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1TagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1TagResourceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1TagResourceCommand = deserializeAws_json1_1TagResourceCommand;
const deserializeAws_json1_1TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ConflictException":
        case "com.amazonaws.transcribe#ConflictException":
            response = {
                ...(await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UntagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UntagResourceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UntagResourceCommand = deserializeAws_json1_1UntagResourceCommand;
const deserializeAws_json1_1UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ConflictException":
        case "com.amazonaws.transcribe#ConflictException":
            response = {
                ...(await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1UpdateCallAnalyticsCategoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateCallAnalyticsCategoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateCallAnalyticsCategoryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UpdateCallAnalyticsCategoryCommand = deserializeAws_json1_1UpdateCallAnalyticsCategoryCommand;
const deserializeAws_json1_1UpdateCallAnalyticsCategoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ConflictException":
        case "com.amazonaws.transcribe#ConflictException":
            response = {
                ...(await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1UpdateMedicalVocabularyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateMedicalVocabularyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateMedicalVocabularyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UpdateMedicalVocabularyCommand = deserializeAws_json1_1UpdateMedicalVocabularyCommand;
const deserializeAws_json1_1UpdateMedicalVocabularyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ConflictException":
        case "com.amazonaws.transcribe#ConflictException":
            response = {
                ...(await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1UpdateVocabularyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateVocabularyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateVocabularyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UpdateVocabularyCommand = deserializeAws_json1_1UpdateVocabularyCommand;
const deserializeAws_json1_1UpdateVocabularyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ConflictException":
        case "com.amazonaws.transcribe#ConflictException":
            response = {
                ...(await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1UpdateVocabularyFilterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateVocabularyFilterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateVocabularyFilterResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UpdateVocabularyFilterCommand = deserializeAws_json1_1UpdateVocabularyFilterCommand;
const deserializeAws_json1_1UpdateVocabularyFilterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.transcribe#BadRequestException":
            response = {
                ...(await deserializeAws_json1_1BadRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.transcribe#InternalFailureException":
            response = {
                ...(await deserializeAws_json1_1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.transcribe#LimitExceededException":
            response = {
                ...(await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotFoundException":
        case "com.amazonaws.transcribe#NotFoundException":
            response = {
                ...(await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_json1_1BadRequestExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1BadRequestException(body, context);
    const contents = {
        name: "BadRequestException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    };
    return contents;
};
const deserializeAws_json1_1ConflictExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ConflictException(body, context);
    const contents = {
        name: "ConflictException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    };
    return contents;
};
const deserializeAws_json1_1InternalFailureExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InternalFailureException(body, context);
    const contents = {
        name: "InternalFailureException",
        $fault: "server",
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    };
    return contents;
};
const deserializeAws_json1_1LimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1LimitExceededException(body, context);
    const contents = {
        name: "LimitExceededException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    };
    return contents;
};
const deserializeAws_json1_1NotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1NotFoundException(body, context);
    const contents = {
        name: "NotFoundException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    };
    return contents;
};
const serializeAws_json1_1AbsoluteTimeRange = (input, context) => {
    return {
        ...(input.EndTime !== undefined && input.EndTime !== null && { EndTime: input.EndTime }),
        ...(input.First !== undefined && input.First !== null && { First: input.First }),
        ...(input.Last !== undefined && input.Last !== null && { Last: input.Last }),
        ...(input.StartTime !== undefined && input.StartTime !== null && { StartTime: input.StartTime }),
    };
};
const serializeAws_json1_1CallAnalyticsJobSettings = (input, context) => {
    return {
        ...(input.ContentRedaction !== undefined &&
            input.ContentRedaction !== null && {
            ContentRedaction: serializeAws_json1_1ContentRedaction(input.ContentRedaction, context),
        }),
        ...(input.LanguageModelName !== undefined &&
            input.LanguageModelName !== null && { LanguageModelName: input.LanguageModelName }),
        ...(input.LanguageOptions !== undefined &&
            input.LanguageOptions !== null && {
            LanguageOptions: serializeAws_json1_1LanguageOptions(input.LanguageOptions, context),
        }),
        ...(input.VocabularyFilterMethod !== undefined &&
            input.VocabularyFilterMethod !== null && { VocabularyFilterMethod: input.VocabularyFilterMethod }),
        ...(input.VocabularyFilterName !== undefined &&
            input.VocabularyFilterName !== null && { VocabularyFilterName: input.VocabularyFilterName }),
        ...(input.VocabularyName !== undefined &&
            input.VocabularyName !== null && { VocabularyName: input.VocabularyName }),
    };
};
const serializeAws_json1_1ChannelDefinition = (input, context) => {
    return {
        ...(input.ChannelId !== undefined && input.ChannelId !== null && { ChannelId: input.ChannelId }),
        ...(input.ParticipantRole !== undefined &&
            input.ParticipantRole !== null && { ParticipantRole: input.ParticipantRole }),
    };
};
const serializeAws_json1_1ChannelDefinitions = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_json1_1ChannelDefinition(entry, context);
    });
};
const serializeAws_json1_1ContentRedaction = (input, context) => {
    return {
        ...(input.RedactionOutput !== undefined &&
            input.RedactionOutput !== null && { RedactionOutput: input.RedactionOutput }),
        ...(input.RedactionType !== undefined && input.RedactionType !== null && { RedactionType: input.RedactionType }),
    };
};
const serializeAws_json1_1CreateCallAnalyticsCategoryRequest = (input, context) => {
    return {
        ...(input.CategoryName !== undefined && input.CategoryName !== null && { CategoryName: input.CategoryName }),
        ...(input.Rules !== undefined &&
            input.Rules !== null && { Rules: serializeAws_json1_1RuleList(input.Rules, context) }),
    };
};
const serializeAws_json1_1CreateLanguageModelRequest = (input, context) => {
    return {
        ...(input.BaseModelName !== undefined && input.BaseModelName !== null && { BaseModelName: input.BaseModelName }),
        ...(input.InputDataConfig !== undefined &&
            input.InputDataConfig !== null && {
            InputDataConfig: serializeAws_json1_1InputDataConfig(input.InputDataConfig, context),
        }),
        ...(input.LanguageCode !== undefined && input.LanguageCode !== null && { LanguageCode: input.LanguageCode }),
        ...(input.ModelName !== undefined && input.ModelName !== null && { ModelName: input.ModelName }),
        ...(input.Tags !== undefined && input.Tags !== null && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
    };
};
const serializeAws_json1_1CreateMedicalVocabularyRequest = (input, context) => {
    return {
        ...(input.LanguageCode !== undefined && input.LanguageCode !== null && { LanguageCode: input.LanguageCode }),
        ...(input.Tags !== undefined && input.Tags !== null && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
        ...(input.VocabularyFileUri !== undefined &&
            input.VocabularyFileUri !== null && { VocabularyFileUri: input.VocabularyFileUri }),
        ...(input.VocabularyName !== undefined &&
            input.VocabularyName !== null && { VocabularyName: input.VocabularyName }),
    };
};
const serializeAws_json1_1CreateVocabularyFilterRequest = (input, context) => {
    return {
        ...(input.LanguageCode !== undefined && input.LanguageCode !== null && { LanguageCode: input.LanguageCode }),
        ...(input.Tags !== undefined && input.Tags !== null && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
        ...(input.VocabularyFilterFileUri !== undefined &&
            input.VocabularyFilterFileUri !== null && { VocabularyFilterFileUri: input.VocabularyFilterFileUri }),
        ...(input.VocabularyFilterName !== undefined &&
            input.VocabularyFilterName !== null && { VocabularyFilterName: input.VocabularyFilterName }),
        ...(input.Words !== undefined &&
            input.Words !== null && { Words: serializeAws_json1_1Words(input.Words, context) }),
    };
};
const serializeAws_json1_1CreateVocabularyRequest = (input, context) => {
    return {
        ...(input.LanguageCode !== undefined && input.LanguageCode !== null && { LanguageCode: input.LanguageCode }),
        ...(input.Phrases !== undefined &&
            input.Phrases !== null && { Phrases: serializeAws_json1_1Phrases(input.Phrases, context) }),
        ...(input.Tags !== undefined && input.Tags !== null && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
        ...(input.VocabularyFileUri !== undefined &&
            input.VocabularyFileUri !== null && { VocabularyFileUri: input.VocabularyFileUri }),
        ...(input.VocabularyName !== undefined &&
            input.VocabularyName !== null && { VocabularyName: input.VocabularyName }),
    };
};
const serializeAws_json1_1DeleteCallAnalyticsCategoryRequest = (input, context) => {
    return {
        ...(input.CategoryName !== undefined && input.CategoryName !== null && { CategoryName: input.CategoryName }),
    };
};
const serializeAws_json1_1DeleteCallAnalyticsJobRequest = (input, context) => {
    return {
        ...(input.CallAnalyticsJobName !== undefined &&
            input.CallAnalyticsJobName !== null && { CallAnalyticsJobName: input.CallAnalyticsJobName }),
    };
};
const serializeAws_json1_1DeleteLanguageModelRequest = (input, context) => {
    return {
        ...(input.ModelName !== undefined && input.ModelName !== null && { ModelName: input.ModelName }),
    };
};
const serializeAws_json1_1DeleteMedicalTranscriptionJobRequest = (input, context) => {
    return {
        ...(input.MedicalTranscriptionJobName !== undefined &&
            input.MedicalTranscriptionJobName !== null && { MedicalTranscriptionJobName: input.MedicalTranscriptionJobName }),
    };
};
const serializeAws_json1_1DeleteMedicalVocabularyRequest = (input, context) => {
    return {
        ...(input.VocabularyName !== undefined &&
            input.VocabularyName !== null && { VocabularyName: input.VocabularyName }),
    };
};
const serializeAws_json1_1DeleteTranscriptionJobRequest = (input, context) => {
    return {
        ...(input.TranscriptionJobName !== undefined &&
            input.TranscriptionJobName !== null && { TranscriptionJobName: input.TranscriptionJobName }),
    };
};
const serializeAws_json1_1DeleteVocabularyFilterRequest = (input, context) => {
    return {
        ...(input.VocabularyFilterName !== undefined &&
            input.VocabularyFilterName !== null && { VocabularyFilterName: input.VocabularyFilterName }),
    };
};
const serializeAws_json1_1DeleteVocabularyRequest = (input, context) => {
    return {
        ...(input.VocabularyName !== undefined &&
            input.VocabularyName !== null && { VocabularyName: input.VocabularyName }),
    };
};
const serializeAws_json1_1DescribeLanguageModelRequest = (input, context) => {
    return {
        ...(input.ModelName !== undefined && input.ModelName !== null && { ModelName: input.ModelName }),
    };
};
const serializeAws_json1_1GetCallAnalyticsCategoryRequest = (input, context) => {
    return {
        ...(input.CategoryName !== undefined && input.CategoryName !== null && { CategoryName: input.CategoryName }),
    };
};
const serializeAws_json1_1GetCallAnalyticsJobRequest = (input, context) => {
    return {
        ...(input.CallAnalyticsJobName !== undefined &&
            input.CallAnalyticsJobName !== null && { CallAnalyticsJobName: input.CallAnalyticsJobName }),
    };
};
const serializeAws_json1_1GetMedicalTranscriptionJobRequest = (input, context) => {
    return {
        ...(input.MedicalTranscriptionJobName !== undefined &&
            input.MedicalTranscriptionJobName !== null && { MedicalTranscriptionJobName: input.MedicalTranscriptionJobName }),
    };
};
const serializeAws_json1_1GetMedicalVocabularyRequest = (input, context) => {
    return {
        ...(input.VocabularyName !== undefined &&
            input.VocabularyName !== null && { VocabularyName: input.VocabularyName }),
    };
};
const serializeAws_json1_1GetTranscriptionJobRequest = (input, context) => {
    return {
        ...(input.TranscriptionJobName !== undefined &&
            input.TranscriptionJobName !== null && { TranscriptionJobName: input.TranscriptionJobName }),
    };
};
const serializeAws_json1_1GetVocabularyFilterRequest = (input, context) => {
    return {
        ...(input.VocabularyFilterName !== undefined &&
            input.VocabularyFilterName !== null && { VocabularyFilterName: input.VocabularyFilterName }),
    };
};
const serializeAws_json1_1GetVocabularyRequest = (input, context) => {
    return {
        ...(input.VocabularyName !== undefined &&
            input.VocabularyName !== null && { VocabularyName: input.VocabularyName }),
    };
};
const serializeAws_json1_1InputDataConfig = (input, context) => {
    return {
        ...(input.DataAccessRoleArn !== undefined &&
            input.DataAccessRoleArn !== null && { DataAccessRoleArn: input.DataAccessRoleArn }),
        ...(input.S3Uri !== undefined && input.S3Uri !== null && { S3Uri: input.S3Uri }),
        ...(input.TuningDataS3Uri !== undefined &&
            input.TuningDataS3Uri !== null && { TuningDataS3Uri: input.TuningDataS3Uri }),
    };
};
const serializeAws_json1_1InterruptionFilter = (input, context) => {
    return {
        ...(input.AbsoluteTimeRange !== undefined &&
            input.AbsoluteTimeRange !== null && {
            AbsoluteTimeRange: serializeAws_json1_1AbsoluteTimeRange(input.AbsoluteTimeRange, context),
        }),
        ...(input.Negate !== undefined && input.Negate !== null && { Negate: input.Negate }),
        ...(input.ParticipantRole !== undefined &&
            input.ParticipantRole !== null && { ParticipantRole: input.ParticipantRole }),
        ...(input.RelativeTimeRange !== undefined &&
            input.RelativeTimeRange !== null && {
            RelativeTimeRange: serializeAws_json1_1RelativeTimeRange(input.RelativeTimeRange, context),
        }),
        ...(input.Threshold !== undefined && input.Threshold !== null && { Threshold: input.Threshold }),
    };
};
const serializeAws_json1_1JobExecutionSettings = (input, context) => {
    return {
        ...(input.AllowDeferredExecution !== undefined &&
            input.AllowDeferredExecution !== null && { AllowDeferredExecution: input.AllowDeferredExecution }),
        ...(input.DataAccessRoleArn !== undefined &&
            input.DataAccessRoleArn !== null && { DataAccessRoleArn: input.DataAccessRoleArn }),
    };
};
const serializeAws_json1_1KMSEncryptionContextMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const serializeAws_json1_1LanguageOptions = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_json1_1ListCallAnalyticsCategoriesRequest = (input, context) => {
    return {
        ...(input.MaxResults !== undefined && input.MaxResults !== null && { MaxResults: input.MaxResults }),
        ...(input.NextToken !== undefined && input.NextToken !== null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1ListCallAnalyticsJobsRequest = (input, context) => {
    return {
        ...(input.JobNameContains !== undefined &&
            input.JobNameContains !== null && { JobNameContains: input.JobNameContains }),
        ...(input.MaxResults !== undefined && input.MaxResults !== null && { MaxResults: input.MaxResults }),
        ...(input.NextToken !== undefined && input.NextToken !== null && { NextToken: input.NextToken }),
        ...(input.Status !== undefined && input.Status !== null && { Status: input.Status }),
    };
};
const serializeAws_json1_1ListLanguageModelsRequest = (input, context) => {
    return {
        ...(input.MaxResults !== undefined && input.MaxResults !== null && { MaxResults: input.MaxResults }),
        ...(input.NameContains !== undefined && input.NameContains !== null && { NameContains: input.NameContains }),
        ...(input.NextToken !== undefined && input.NextToken !== null && { NextToken: input.NextToken }),
        ...(input.StatusEquals !== undefined && input.StatusEquals !== null && { StatusEquals: input.StatusEquals }),
    };
};
const serializeAws_json1_1ListMedicalTranscriptionJobsRequest = (input, context) => {
    return {
        ...(input.JobNameContains !== undefined &&
            input.JobNameContains !== null && { JobNameContains: input.JobNameContains }),
        ...(input.MaxResults !== undefined && input.MaxResults !== null && { MaxResults: input.MaxResults }),
        ...(input.NextToken !== undefined && input.NextToken !== null && { NextToken: input.NextToken }),
        ...(input.Status !== undefined && input.Status !== null && { Status: input.Status }),
    };
};
const serializeAws_json1_1ListMedicalVocabulariesRequest = (input, context) => {
    return {
        ...(input.MaxResults !== undefined && input.MaxResults !== null && { MaxResults: input.MaxResults }),
        ...(input.NameContains !== undefined && input.NameContains !== null && { NameContains: input.NameContains }),
        ...(input.NextToken !== undefined && input.NextToken !== null && { NextToken: input.NextToken }),
        ...(input.StateEquals !== undefined && input.StateEquals !== null && { StateEquals: input.StateEquals }),
    };
};
const serializeAws_json1_1ListTagsForResourceRequest = (input, context) => {
    return {
        ...(input.ResourceArn !== undefined && input.ResourceArn !== null && { ResourceArn: input.ResourceArn }),
    };
};
const serializeAws_json1_1ListTranscriptionJobsRequest = (input, context) => {
    return {
        ...(input.JobNameContains !== undefined &&
            input.JobNameContains !== null && { JobNameContains: input.JobNameContains }),
        ...(input.MaxResults !== undefined && input.MaxResults !== null && { MaxResults: input.MaxResults }),
        ...(input.NextToken !== undefined && input.NextToken !== null && { NextToken: input.NextToken }),
        ...(input.Status !== undefined && input.Status !== null && { Status: input.Status }),
    };
};
const serializeAws_json1_1ListVocabulariesRequest = (input, context) => {
    return {
        ...(input.MaxResults !== undefined && input.MaxResults !== null && { MaxResults: input.MaxResults }),
        ...(input.NameContains !== undefined && input.NameContains !== null && { NameContains: input.NameContains }),
        ...(input.NextToken !== undefined && input.NextToken !== null && { NextToken: input.NextToken }),
        ...(input.StateEquals !== undefined && input.StateEquals !== null && { StateEquals: input.StateEquals }),
    };
};
const serializeAws_json1_1ListVocabularyFiltersRequest = (input, context) => {
    return {
        ...(input.MaxResults !== undefined && input.MaxResults !== null && { MaxResults: input.MaxResults }),
        ...(input.NameContains !== undefined && input.NameContains !== null && { NameContains: input.NameContains }),
        ...(input.NextToken !== undefined && input.NextToken !== null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1Media = (input, context) => {
    return {
        ...(input.MediaFileUri !== undefined && input.MediaFileUri !== null && { MediaFileUri: input.MediaFileUri }),
        ...(input.RedactedMediaFileUri !== undefined &&
            input.RedactedMediaFileUri !== null && { RedactedMediaFileUri: input.RedactedMediaFileUri }),
    };
};
const serializeAws_json1_1MedicalTranscriptionSetting = (input, context) => {
    return {
        ...(input.ChannelIdentification !== undefined &&
            input.ChannelIdentification !== null && { ChannelIdentification: input.ChannelIdentification }),
        ...(input.MaxAlternatives !== undefined &&
            input.MaxAlternatives !== null && { MaxAlternatives: input.MaxAlternatives }),
        ...(input.MaxSpeakerLabels !== undefined &&
            input.MaxSpeakerLabels !== null && { MaxSpeakerLabels: input.MaxSpeakerLabels }),
        ...(input.ShowAlternatives !== undefined &&
            input.ShowAlternatives !== null && { ShowAlternatives: input.ShowAlternatives }),
        ...(input.ShowSpeakerLabels !== undefined &&
            input.ShowSpeakerLabels !== null && { ShowSpeakerLabels: input.ShowSpeakerLabels }),
        ...(input.VocabularyName !== undefined &&
            input.VocabularyName !== null && { VocabularyName: input.VocabularyName }),
    };
};
const serializeAws_json1_1ModelSettings = (input, context) => {
    return {
        ...(input.LanguageModelName !== undefined &&
            input.LanguageModelName !== null && { LanguageModelName: input.LanguageModelName }),
    };
};
const serializeAws_json1_1NonTalkTimeFilter = (input, context) => {
    return {
        ...(input.AbsoluteTimeRange !== undefined &&
            input.AbsoluteTimeRange !== null && {
            AbsoluteTimeRange: serializeAws_json1_1AbsoluteTimeRange(input.AbsoluteTimeRange, context),
        }),
        ...(input.Negate !== undefined && input.Negate !== null && { Negate: input.Negate }),
        ...(input.RelativeTimeRange !== undefined &&
            input.RelativeTimeRange !== null && {
            RelativeTimeRange: serializeAws_json1_1RelativeTimeRange(input.RelativeTimeRange, context),
        }),
        ...(input.Threshold !== undefined && input.Threshold !== null && { Threshold: input.Threshold }),
    };
};
const serializeAws_json1_1Phrases = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_json1_1RelativeTimeRange = (input, context) => {
    return {
        ...(input.EndPercentage !== undefined && input.EndPercentage !== null && { EndPercentage: input.EndPercentage }),
        ...(input.First !== undefined && input.First !== null && { First: input.First }),
        ...(input.Last !== undefined && input.Last !== null && { Last: input.Last }),
        ...(input.StartPercentage !== undefined &&
            input.StartPercentage !== null && { StartPercentage: input.StartPercentage }),
    };
};
const serializeAws_json1_1Rule = (input, context) => {
    return models_0_1.Rule.visit(input, {
        InterruptionFilter: (value) => ({ InterruptionFilter: serializeAws_json1_1InterruptionFilter(value, context) }),
        NonTalkTimeFilter: (value) => ({ NonTalkTimeFilter: serializeAws_json1_1NonTalkTimeFilter(value, context) }),
        SentimentFilter: (value) => ({ SentimentFilter: serializeAws_json1_1SentimentFilter(value, context) }),
        TranscriptFilter: (value) => ({ TranscriptFilter: serializeAws_json1_1TranscriptFilter(value, context) }),
        _: (name, value) => ({ name: value }),
    });
};
const serializeAws_json1_1RuleList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_json1_1Rule(entry, context);
    });
};
const serializeAws_json1_1SentimentFilter = (input, context) => {
    return {
        ...(input.AbsoluteTimeRange !== undefined &&
            input.AbsoluteTimeRange !== null && {
            AbsoluteTimeRange: serializeAws_json1_1AbsoluteTimeRange(input.AbsoluteTimeRange, context),
        }),
        ...(input.Negate !== undefined && input.Negate !== null && { Negate: input.Negate }),
        ...(input.ParticipantRole !== undefined &&
            input.ParticipantRole !== null && { ParticipantRole: input.ParticipantRole }),
        ...(input.RelativeTimeRange !== undefined &&
            input.RelativeTimeRange !== null && {
            RelativeTimeRange: serializeAws_json1_1RelativeTimeRange(input.RelativeTimeRange, context),
        }),
        ...(input.Sentiments !== undefined &&
            input.Sentiments !== null && { Sentiments: serializeAws_json1_1SentimentValueList(input.Sentiments, context) }),
    };
};
const serializeAws_json1_1SentimentValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_json1_1Settings = (input, context) => {
    return {
        ...(input.ChannelIdentification !== undefined &&
            input.ChannelIdentification !== null && { ChannelIdentification: input.ChannelIdentification }),
        ...(input.MaxAlternatives !== undefined &&
            input.MaxAlternatives !== null && { MaxAlternatives: input.MaxAlternatives }),
        ...(input.MaxSpeakerLabels !== undefined &&
            input.MaxSpeakerLabels !== null && { MaxSpeakerLabels: input.MaxSpeakerLabels }),
        ...(input.ShowAlternatives !== undefined &&
            input.ShowAlternatives !== null && { ShowAlternatives: input.ShowAlternatives }),
        ...(input.ShowSpeakerLabels !== undefined &&
            input.ShowSpeakerLabels !== null && { ShowSpeakerLabels: input.ShowSpeakerLabels }),
        ...(input.VocabularyFilterMethod !== undefined &&
            input.VocabularyFilterMethod !== null && { VocabularyFilterMethod: input.VocabularyFilterMethod }),
        ...(input.VocabularyFilterName !== undefined &&
            input.VocabularyFilterName !== null && { VocabularyFilterName: input.VocabularyFilterName }),
        ...(input.VocabularyName !== undefined &&
            input.VocabularyName !== null && { VocabularyName: input.VocabularyName }),
    };
};
const serializeAws_json1_1StartCallAnalyticsJobRequest = (input, context) => {
    return {
        ...(input.CallAnalyticsJobName !== undefined &&
            input.CallAnalyticsJobName !== null && { CallAnalyticsJobName: input.CallAnalyticsJobName }),
        ...(input.ChannelDefinitions !== undefined &&
            input.ChannelDefinitions !== null && {
            ChannelDefinitions: serializeAws_json1_1ChannelDefinitions(input.ChannelDefinitions, context),
        }),
        ...(input.DataAccessRoleArn !== undefined &&
            input.DataAccessRoleArn !== null && { DataAccessRoleArn: input.DataAccessRoleArn }),
        ...(input.Media !== undefined &&
            input.Media !== null && { Media: serializeAws_json1_1Media(input.Media, context) }),
        ...(input.OutputEncryptionKMSKeyId !== undefined &&
            input.OutputEncryptionKMSKeyId !== null && { OutputEncryptionKMSKeyId: input.OutputEncryptionKMSKeyId }),
        ...(input.OutputLocation !== undefined &&
            input.OutputLocation !== null && { OutputLocation: input.OutputLocation }),
        ...(input.Settings !== undefined &&
            input.Settings !== null && { Settings: serializeAws_json1_1CallAnalyticsJobSettings(input.Settings, context) }),
    };
};
const serializeAws_json1_1StartMedicalTranscriptionJobRequest = (input, context) => {
    return {
        ...(input.ContentIdentificationType !== undefined &&
            input.ContentIdentificationType !== null && { ContentIdentificationType: input.ContentIdentificationType }),
        ...(input.KMSEncryptionContext !== undefined &&
            input.KMSEncryptionContext !== null && {
            KMSEncryptionContext: serializeAws_json1_1KMSEncryptionContextMap(input.KMSEncryptionContext, context),
        }),
        ...(input.LanguageCode !== undefined && input.LanguageCode !== null && { LanguageCode: input.LanguageCode }),
        ...(input.Media !== undefined &&
            input.Media !== null && { Media: serializeAws_json1_1Media(input.Media, context) }),
        ...(input.MediaFormat !== undefined && input.MediaFormat !== null && { MediaFormat: input.MediaFormat }),
        ...(input.MediaSampleRateHertz !== undefined &&
            input.MediaSampleRateHertz !== null && { MediaSampleRateHertz: input.MediaSampleRateHertz }),
        ...(input.MedicalTranscriptionJobName !== undefined &&
            input.MedicalTranscriptionJobName !== null && { MedicalTranscriptionJobName: input.MedicalTranscriptionJobName }),
        ...(input.OutputBucketName !== undefined &&
            input.OutputBucketName !== null && { OutputBucketName: input.OutputBucketName }),
        ...(input.OutputEncryptionKMSKeyId !== undefined &&
            input.OutputEncryptionKMSKeyId !== null && { OutputEncryptionKMSKeyId: input.OutputEncryptionKMSKeyId }),
        ...(input.OutputKey !== undefined && input.OutputKey !== null && { OutputKey: input.OutputKey }),
        ...(input.Settings !== undefined &&
            input.Settings !== null && {
            Settings: serializeAws_json1_1MedicalTranscriptionSetting(input.Settings, context),
        }),
        ...(input.Specialty !== undefined && input.Specialty !== null && { Specialty: input.Specialty }),
        ...(input.Tags !== undefined && input.Tags !== null && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
        ...(input.Type !== undefined && input.Type !== null && { Type: input.Type }),
    };
};
const serializeAws_json1_1StartTranscriptionJobRequest = (input, context) => {
    return {
        ...(input.ContentRedaction !== undefined &&
            input.ContentRedaction !== null && {
            ContentRedaction: serializeAws_json1_1ContentRedaction(input.ContentRedaction, context),
        }),
        ...(input.IdentifyLanguage !== undefined &&
            input.IdentifyLanguage !== null && { IdentifyLanguage: input.IdentifyLanguage }),
        ...(input.JobExecutionSettings !== undefined &&
            input.JobExecutionSettings !== null && {
            JobExecutionSettings: serializeAws_json1_1JobExecutionSettings(input.JobExecutionSettings, context),
        }),
        ...(input.KMSEncryptionContext !== undefined &&
            input.KMSEncryptionContext !== null && {
            KMSEncryptionContext: serializeAws_json1_1KMSEncryptionContextMap(input.KMSEncryptionContext, context),
        }),
        ...(input.LanguageCode !== undefined && input.LanguageCode !== null && { LanguageCode: input.LanguageCode }),
        ...(input.LanguageOptions !== undefined &&
            input.LanguageOptions !== null && {
            LanguageOptions: serializeAws_json1_1LanguageOptions(input.LanguageOptions, context),
        }),
        ...(input.Media !== undefined &&
            input.Media !== null && { Media: serializeAws_json1_1Media(input.Media, context) }),
        ...(input.MediaFormat !== undefined && input.MediaFormat !== null && { MediaFormat: input.MediaFormat }),
        ...(input.MediaSampleRateHertz !== undefined &&
            input.MediaSampleRateHertz !== null && { MediaSampleRateHertz: input.MediaSampleRateHertz }),
        ...(input.ModelSettings !== undefined &&
            input.ModelSettings !== null && {
            ModelSettings: serializeAws_json1_1ModelSettings(input.ModelSettings, context),
        }),
        ...(input.OutputBucketName !== undefined &&
            input.OutputBucketName !== null && { OutputBucketName: input.OutputBucketName }),
        ...(input.OutputEncryptionKMSKeyId !== undefined &&
            input.OutputEncryptionKMSKeyId !== null && { OutputEncryptionKMSKeyId: input.OutputEncryptionKMSKeyId }),
        ...(input.OutputKey !== undefined && input.OutputKey !== null && { OutputKey: input.OutputKey }),
        ...(input.Settings !== undefined &&
            input.Settings !== null && { Settings: serializeAws_json1_1Settings(input.Settings, context) }),
        ...(input.Subtitles !== undefined &&
            input.Subtitles !== null && { Subtitles: serializeAws_json1_1Subtitles(input.Subtitles, context) }),
        ...(input.Tags !== undefined && input.Tags !== null && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
        ...(input.TranscriptionJobName !== undefined &&
            input.TranscriptionJobName !== null && { TranscriptionJobName: input.TranscriptionJobName }),
    };
};
const serializeAws_json1_1StringTargetList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_json1_1SubtitleFormats = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_json1_1Subtitles = (input, context) => {
    return {
        ...(input.Formats !== undefined &&
            input.Formats !== null && { Formats: serializeAws_json1_1SubtitleFormats(input.Formats, context) }),
    };
};
const serializeAws_json1_1Tag = (input, context) => {
    return {
        ...(input.Key !== undefined && input.Key !== null && { Key: input.Key }),
        ...(input.Value !== undefined && input.Value !== null && { Value: input.Value }),
    };
};
const serializeAws_json1_1TagKeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_json1_1TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_json1_1Tag(entry, context);
    });
};
const serializeAws_json1_1TagResourceRequest = (input, context) => {
    return {
        ...(input.ResourceArn !== undefined && input.ResourceArn !== null && { ResourceArn: input.ResourceArn }),
        ...(input.Tags !== undefined && input.Tags !== null && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
    };
};
const serializeAws_json1_1TranscriptFilter = (input, context) => {
    return {
        ...(input.AbsoluteTimeRange !== undefined &&
            input.AbsoluteTimeRange !== null && {
            AbsoluteTimeRange: serializeAws_json1_1AbsoluteTimeRange(input.AbsoluteTimeRange, context),
        }),
        ...(input.Negate !== undefined && input.Negate !== null && { Negate: input.Negate }),
        ...(input.ParticipantRole !== undefined &&
            input.ParticipantRole !== null && { ParticipantRole: input.ParticipantRole }),
        ...(input.RelativeTimeRange !== undefined &&
            input.RelativeTimeRange !== null && {
            RelativeTimeRange: serializeAws_json1_1RelativeTimeRange(input.RelativeTimeRange, context),
        }),
        ...(input.Targets !== undefined &&
            input.Targets !== null && { Targets: serializeAws_json1_1StringTargetList(input.Targets, context) }),
        ...(input.TranscriptFilterType !== undefined &&
            input.TranscriptFilterType !== null && { TranscriptFilterType: input.TranscriptFilterType }),
    };
};
const serializeAws_json1_1UntagResourceRequest = (input, context) => {
    return {
        ...(input.ResourceArn !== undefined && input.ResourceArn !== null && { ResourceArn: input.ResourceArn }),
        ...(input.TagKeys !== undefined &&
            input.TagKeys !== null && { TagKeys: serializeAws_json1_1TagKeyList(input.TagKeys, context) }),
    };
};
const serializeAws_json1_1UpdateCallAnalyticsCategoryRequest = (input, context) => {
    return {
        ...(input.CategoryName !== undefined && input.CategoryName !== null && { CategoryName: input.CategoryName }),
        ...(input.Rules !== undefined &&
            input.Rules !== null && { Rules: serializeAws_json1_1RuleList(input.Rules, context) }),
    };
};
const serializeAws_json1_1UpdateMedicalVocabularyRequest = (input, context) => {
    return {
        ...(input.LanguageCode !== undefined && input.LanguageCode !== null && { LanguageCode: input.LanguageCode }),
        ...(input.VocabularyFileUri !== undefined &&
            input.VocabularyFileUri !== null && { VocabularyFileUri: input.VocabularyFileUri }),
        ...(input.VocabularyName !== undefined &&
            input.VocabularyName !== null && { VocabularyName: input.VocabularyName }),
    };
};
const serializeAws_json1_1UpdateVocabularyFilterRequest = (input, context) => {
    return {
        ...(input.VocabularyFilterFileUri !== undefined &&
            input.VocabularyFilterFileUri !== null && { VocabularyFilterFileUri: input.VocabularyFilterFileUri }),
        ...(input.VocabularyFilterName !== undefined &&
            input.VocabularyFilterName !== null && { VocabularyFilterName: input.VocabularyFilterName }),
        ...(input.Words !== undefined &&
            input.Words !== null && { Words: serializeAws_json1_1Words(input.Words, context) }),
    };
};
const serializeAws_json1_1UpdateVocabularyRequest = (input, context) => {
    return {
        ...(input.LanguageCode !== undefined && input.LanguageCode !== null && { LanguageCode: input.LanguageCode }),
        ...(input.Phrases !== undefined &&
            input.Phrases !== null && { Phrases: serializeAws_json1_1Phrases(input.Phrases, context) }),
        ...(input.VocabularyFileUri !== undefined &&
            input.VocabularyFileUri !== null && { VocabularyFileUri: input.VocabularyFileUri }),
        ...(input.VocabularyName !== undefined &&
            input.VocabularyName !== null && { VocabularyName: input.VocabularyName }),
    };
};
const serializeAws_json1_1Words = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_json1_1AbsoluteTimeRange = (output, context) => {
    return {
        EndTime: smithy_client_1.expectLong(output.EndTime),
        First: smithy_client_1.expectLong(output.First),
        Last: smithy_client_1.expectLong(output.Last),
        StartTime: smithy_client_1.expectLong(output.StartTime),
    };
};
const deserializeAws_json1_1BadRequestException = (output, context) => {
    return {
        Message: smithy_client_1.expectString(output.Message),
    };
};
const deserializeAws_json1_1CallAnalyticsJob = (output, context) => {
    return {
        CallAnalyticsJobName: smithy_client_1.expectString(output.CallAnalyticsJobName),
        CallAnalyticsJobStatus: smithy_client_1.expectString(output.CallAnalyticsJobStatus),
        ChannelDefinitions: output.ChannelDefinitions !== undefined && output.ChannelDefinitions !== null
            ? deserializeAws_json1_1ChannelDefinitions(output.ChannelDefinitions, context)
            : undefined,
        CompletionTime: output.CompletionTime !== undefined && output.CompletionTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.CompletionTime)))
            : undefined,
        CreationTime: output.CreationTime !== undefined && output.CreationTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.CreationTime)))
            : undefined,
        DataAccessRoleArn: smithy_client_1.expectString(output.DataAccessRoleArn),
        FailureReason: smithy_client_1.expectString(output.FailureReason),
        IdentifiedLanguageScore: smithy_client_1.limitedParseFloat32(output.IdentifiedLanguageScore),
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        Media: output.Media !== undefined && output.Media !== null
            ? deserializeAws_json1_1Media(output.Media, context)
            : undefined,
        MediaFormat: smithy_client_1.expectString(output.MediaFormat),
        MediaSampleRateHertz: smithy_client_1.expectInt32(output.MediaSampleRateHertz),
        Settings: output.Settings !== undefined && output.Settings !== null
            ? deserializeAws_json1_1CallAnalyticsJobSettings(output.Settings, context)
            : undefined,
        StartTime: output.StartTime !== undefined && output.StartTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.StartTime)))
            : undefined,
        Transcript: output.Transcript !== undefined && output.Transcript !== null
            ? deserializeAws_json1_1Transcript(output.Transcript, context)
            : undefined,
    };
};
const deserializeAws_json1_1CallAnalyticsJobSettings = (output, context) => {
    return {
        ContentRedaction: output.ContentRedaction !== undefined && output.ContentRedaction !== null
            ? deserializeAws_json1_1ContentRedaction(output.ContentRedaction, context)
            : undefined,
        LanguageModelName: smithy_client_1.expectString(output.LanguageModelName),
        LanguageOptions: output.LanguageOptions !== undefined && output.LanguageOptions !== null
            ? deserializeAws_json1_1LanguageOptions(output.LanguageOptions, context)
            : undefined,
        VocabularyFilterMethod: smithy_client_1.expectString(output.VocabularyFilterMethod),
        VocabularyFilterName: smithy_client_1.expectString(output.VocabularyFilterName),
        VocabularyName: smithy_client_1.expectString(output.VocabularyName),
    };
};
const deserializeAws_json1_1CallAnalyticsJobSummaries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1CallAnalyticsJobSummary(entry, context);
    });
};
const deserializeAws_json1_1CallAnalyticsJobSummary = (output, context) => {
    return {
        CallAnalyticsJobName: smithy_client_1.expectString(output.CallAnalyticsJobName),
        CallAnalyticsJobStatus: smithy_client_1.expectString(output.CallAnalyticsJobStatus),
        CompletionTime: output.CompletionTime !== undefined && output.CompletionTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.CompletionTime)))
            : undefined,
        CreationTime: output.CreationTime !== undefined && output.CreationTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.CreationTime)))
            : undefined,
        FailureReason: smithy_client_1.expectString(output.FailureReason),
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        StartTime: output.StartTime !== undefined && output.StartTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.StartTime)))
            : undefined,
    };
};
const deserializeAws_json1_1CategoryProperties = (output, context) => {
    return {
        CategoryName: smithy_client_1.expectString(output.CategoryName),
        CreateTime: output.CreateTime !== undefined && output.CreateTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.CreateTime)))
            : undefined,
        LastUpdateTime: output.LastUpdateTime !== undefined && output.LastUpdateTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.LastUpdateTime)))
            : undefined,
        Rules: output.Rules !== undefined && output.Rules !== null
            ? deserializeAws_json1_1RuleList(output.Rules, context)
            : undefined,
    };
};
const deserializeAws_json1_1CategoryPropertiesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1CategoryProperties(entry, context);
    });
};
const deserializeAws_json1_1ChannelDefinition = (output, context) => {
    return {
        ChannelId: smithy_client_1.expectInt32(output.ChannelId),
        ParticipantRole: smithy_client_1.expectString(output.ParticipantRole),
    };
};
const deserializeAws_json1_1ChannelDefinitions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ChannelDefinition(entry, context);
    });
};
const deserializeAws_json1_1ConflictException = (output, context) => {
    return {
        Message: smithy_client_1.expectString(output.Message),
    };
};
const deserializeAws_json1_1ContentRedaction = (output, context) => {
    return {
        RedactionOutput: smithy_client_1.expectString(output.RedactionOutput),
        RedactionType: smithy_client_1.expectString(output.RedactionType),
    };
};
const deserializeAws_json1_1CreateCallAnalyticsCategoryResponse = (output, context) => {
    return {
        CategoryProperties: output.CategoryProperties !== undefined && output.CategoryProperties !== null
            ? deserializeAws_json1_1CategoryProperties(output.CategoryProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1CreateLanguageModelResponse = (output, context) => {
    return {
        BaseModelName: smithy_client_1.expectString(output.BaseModelName),
        InputDataConfig: output.InputDataConfig !== undefined && output.InputDataConfig !== null
            ? deserializeAws_json1_1InputDataConfig(output.InputDataConfig, context)
            : undefined,
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        ModelName: smithy_client_1.expectString(output.ModelName),
        ModelStatus: smithy_client_1.expectString(output.ModelStatus),
    };
};
const deserializeAws_json1_1CreateMedicalVocabularyResponse = (output, context) => {
    return {
        FailureReason: smithy_client_1.expectString(output.FailureReason),
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        LastModifiedTime: output.LastModifiedTime !== undefined && output.LastModifiedTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.LastModifiedTime)))
            : undefined,
        VocabularyName: smithy_client_1.expectString(output.VocabularyName),
        VocabularyState: smithy_client_1.expectString(output.VocabularyState),
    };
};
const deserializeAws_json1_1CreateVocabularyFilterResponse = (output, context) => {
    return {
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        LastModifiedTime: output.LastModifiedTime !== undefined && output.LastModifiedTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.LastModifiedTime)))
            : undefined,
        VocabularyFilterName: smithy_client_1.expectString(output.VocabularyFilterName),
    };
};
const deserializeAws_json1_1CreateVocabularyResponse = (output, context) => {
    return {
        FailureReason: smithy_client_1.expectString(output.FailureReason),
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        LastModifiedTime: output.LastModifiedTime !== undefined && output.LastModifiedTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.LastModifiedTime)))
            : undefined,
        VocabularyName: smithy_client_1.expectString(output.VocabularyName),
        VocabularyState: smithy_client_1.expectString(output.VocabularyState),
    };
};
const deserializeAws_json1_1DeleteCallAnalyticsCategoryResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeleteCallAnalyticsJobResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DescribeLanguageModelResponse = (output, context) => {
    return {
        LanguageModel: output.LanguageModel !== undefined && output.LanguageModel !== null
            ? deserializeAws_json1_1LanguageModel(output.LanguageModel, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetCallAnalyticsCategoryResponse = (output, context) => {
    return {
        CategoryProperties: output.CategoryProperties !== undefined && output.CategoryProperties !== null
            ? deserializeAws_json1_1CategoryProperties(output.CategoryProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetCallAnalyticsJobResponse = (output, context) => {
    return {
        CallAnalyticsJob: output.CallAnalyticsJob !== undefined && output.CallAnalyticsJob !== null
            ? deserializeAws_json1_1CallAnalyticsJob(output.CallAnalyticsJob, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetMedicalTranscriptionJobResponse = (output, context) => {
    return {
        MedicalTranscriptionJob: output.MedicalTranscriptionJob !== undefined && output.MedicalTranscriptionJob !== null
            ? deserializeAws_json1_1MedicalTranscriptionJob(output.MedicalTranscriptionJob, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetMedicalVocabularyResponse = (output, context) => {
    return {
        DownloadUri: smithy_client_1.expectString(output.DownloadUri),
        FailureReason: smithy_client_1.expectString(output.FailureReason),
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        LastModifiedTime: output.LastModifiedTime !== undefined && output.LastModifiedTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.LastModifiedTime)))
            : undefined,
        VocabularyName: smithy_client_1.expectString(output.VocabularyName),
        VocabularyState: smithy_client_1.expectString(output.VocabularyState),
    };
};
const deserializeAws_json1_1GetTranscriptionJobResponse = (output, context) => {
    return {
        TranscriptionJob: output.TranscriptionJob !== undefined && output.TranscriptionJob !== null
            ? deserializeAws_json1_1TranscriptionJob(output.TranscriptionJob, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetVocabularyFilterResponse = (output, context) => {
    return {
        DownloadUri: smithy_client_1.expectString(output.DownloadUri),
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        LastModifiedTime: output.LastModifiedTime !== undefined && output.LastModifiedTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.LastModifiedTime)))
            : undefined,
        VocabularyFilterName: smithy_client_1.expectString(output.VocabularyFilterName),
    };
};
const deserializeAws_json1_1GetVocabularyResponse = (output, context) => {
    return {
        DownloadUri: smithy_client_1.expectString(output.DownloadUri),
        FailureReason: smithy_client_1.expectString(output.FailureReason),
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        LastModifiedTime: output.LastModifiedTime !== undefined && output.LastModifiedTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.LastModifiedTime)))
            : undefined,
        VocabularyName: smithy_client_1.expectString(output.VocabularyName),
        VocabularyState: smithy_client_1.expectString(output.VocabularyState),
    };
};
const deserializeAws_json1_1InputDataConfig = (output, context) => {
    return {
        DataAccessRoleArn: smithy_client_1.expectString(output.DataAccessRoleArn),
        S3Uri: smithy_client_1.expectString(output.S3Uri),
        TuningDataS3Uri: smithy_client_1.expectString(output.TuningDataS3Uri),
    };
};
const deserializeAws_json1_1InternalFailureException = (output, context) => {
    return {
        Message: smithy_client_1.expectString(output.Message),
    };
};
const deserializeAws_json1_1InterruptionFilter = (output, context) => {
    return {
        AbsoluteTimeRange: output.AbsoluteTimeRange !== undefined && output.AbsoluteTimeRange !== null
            ? deserializeAws_json1_1AbsoluteTimeRange(output.AbsoluteTimeRange, context)
            : undefined,
        Negate: smithy_client_1.expectBoolean(output.Negate),
        ParticipantRole: smithy_client_1.expectString(output.ParticipantRole),
        RelativeTimeRange: output.RelativeTimeRange !== undefined && output.RelativeTimeRange !== null
            ? deserializeAws_json1_1RelativeTimeRange(output.RelativeTimeRange, context)
            : undefined,
        Threshold: smithy_client_1.expectLong(output.Threshold),
    };
};
const deserializeAws_json1_1JobExecutionSettings = (output, context) => {
    return {
        AllowDeferredExecution: smithy_client_1.expectBoolean(output.AllowDeferredExecution),
        DataAccessRoleArn: smithy_client_1.expectString(output.DataAccessRoleArn),
    };
};
const deserializeAws_json1_1LanguageModel = (output, context) => {
    return {
        BaseModelName: smithy_client_1.expectString(output.BaseModelName),
        CreateTime: output.CreateTime !== undefined && output.CreateTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.CreateTime)))
            : undefined,
        FailureReason: smithy_client_1.expectString(output.FailureReason),
        InputDataConfig: output.InputDataConfig !== undefined && output.InputDataConfig !== null
            ? deserializeAws_json1_1InputDataConfig(output.InputDataConfig, context)
            : undefined,
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        LastModifiedTime: output.LastModifiedTime !== undefined && output.LastModifiedTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.LastModifiedTime)))
            : undefined,
        ModelName: smithy_client_1.expectString(output.ModelName),
        ModelStatus: smithy_client_1.expectString(output.ModelStatus),
        UpgradeAvailability: smithy_client_1.expectBoolean(output.UpgradeAvailability),
    };
};
const deserializeAws_json1_1LanguageOptions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return smithy_client_1.expectString(entry);
    });
};
const deserializeAws_json1_1LimitExceededException = (output, context) => {
    return {
        Message: smithy_client_1.expectString(output.Message),
    };
};
const deserializeAws_json1_1ListCallAnalyticsCategoriesResponse = (output, context) => {
    return {
        Categories: output.Categories !== undefined && output.Categories !== null
            ? deserializeAws_json1_1CategoryPropertiesList(output.Categories, context)
            : undefined,
        NextToken: smithy_client_1.expectString(output.NextToken),
    };
};
const deserializeAws_json1_1ListCallAnalyticsJobsResponse = (output, context) => {
    return {
        CallAnalyticsJobSummaries: output.CallAnalyticsJobSummaries !== undefined && output.CallAnalyticsJobSummaries !== null
            ? deserializeAws_json1_1CallAnalyticsJobSummaries(output.CallAnalyticsJobSummaries, context)
            : undefined,
        NextToken: smithy_client_1.expectString(output.NextToken),
        Status: smithy_client_1.expectString(output.Status),
    };
};
const deserializeAws_json1_1ListLanguageModelsResponse = (output, context) => {
    return {
        Models: output.Models !== undefined && output.Models !== null
            ? deserializeAws_json1_1Models(output.Models, context)
            : undefined,
        NextToken: smithy_client_1.expectString(output.NextToken),
    };
};
const deserializeAws_json1_1ListMedicalTranscriptionJobsResponse = (output, context) => {
    return {
        MedicalTranscriptionJobSummaries: output.MedicalTranscriptionJobSummaries !== undefined && output.MedicalTranscriptionJobSummaries !== null
            ? deserializeAws_json1_1MedicalTranscriptionJobSummaries(output.MedicalTranscriptionJobSummaries, context)
            : undefined,
        NextToken: smithy_client_1.expectString(output.NextToken),
        Status: smithy_client_1.expectString(output.Status),
    };
};
const deserializeAws_json1_1ListMedicalVocabulariesResponse = (output, context) => {
    return {
        NextToken: smithy_client_1.expectString(output.NextToken),
        Status: smithy_client_1.expectString(output.Status),
        Vocabularies: output.Vocabularies !== undefined && output.Vocabularies !== null
            ? deserializeAws_json1_1Vocabularies(output.Vocabularies, context)
            : undefined,
    };
};
const deserializeAws_json1_1ListTagsForResourceResponse = (output, context) => {
    return {
        ResourceArn: smithy_client_1.expectString(output.ResourceArn),
        Tags: output.Tags !== undefined && output.Tags !== null
            ? deserializeAws_json1_1TagList(output.Tags, context)
            : undefined,
    };
};
const deserializeAws_json1_1ListTranscriptionJobsResponse = (output, context) => {
    return {
        NextToken: smithy_client_1.expectString(output.NextToken),
        Status: smithy_client_1.expectString(output.Status),
        TranscriptionJobSummaries: output.TranscriptionJobSummaries !== undefined && output.TranscriptionJobSummaries !== null
            ? deserializeAws_json1_1TranscriptionJobSummaries(output.TranscriptionJobSummaries, context)
            : undefined,
    };
};
const deserializeAws_json1_1ListVocabulariesResponse = (output, context) => {
    return {
        NextToken: smithy_client_1.expectString(output.NextToken),
        Status: smithy_client_1.expectString(output.Status),
        Vocabularies: output.Vocabularies !== undefined && output.Vocabularies !== null
            ? deserializeAws_json1_1Vocabularies(output.Vocabularies, context)
            : undefined,
    };
};
const deserializeAws_json1_1ListVocabularyFiltersResponse = (output, context) => {
    return {
        NextToken: smithy_client_1.expectString(output.NextToken),
        VocabularyFilters: output.VocabularyFilters !== undefined && output.VocabularyFilters !== null
            ? deserializeAws_json1_1VocabularyFilters(output.VocabularyFilters, context)
            : undefined,
    };
};
const deserializeAws_json1_1Media = (output, context) => {
    return {
        MediaFileUri: smithy_client_1.expectString(output.MediaFileUri),
        RedactedMediaFileUri: smithy_client_1.expectString(output.RedactedMediaFileUri),
    };
};
const deserializeAws_json1_1MedicalTranscript = (output, context) => {
    return {
        TranscriptFileUri: smithy_client_1.expectString(output.TranscriptFileUri),
    };
};
const deserializeAws_json1_1MedicalTranscriptionJob = (output, context) => {
    return {
        CompletionTime: output.CompletionTime !== undefined && output.CompletionTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.CompletionTime)))
            : undefined,
        ContentIdentificationType: smithy_client_1.expectString(output.ContentIdentificationType),
        CreationTime: output.CreationTime !== undefined && output.CreationTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.CreationTime)))
            : undefined,
        FailureReason: smithy_client_1.expectString(output.FailureReason),
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        Media: output.Media !== undefined && output.Media !== null
            ? deserializeAws_json1_1Media(output.Media, context)
            : undefined,
        MediaFormat: smithy_client_1.expectString(output.MediaFormat),
        MediaSampleRateHertz: smithy_client_1.expectInt32(output.MediaSampleRateHertz),
        MedicalTranscriptionJobName: smithy_client_1.expectString(output.MedicalTranscriptionJobName),
        Settings: output.Settings !== undefined && output.Settings !== null
            ? deserializeAws_json1_1MedicalTranscriptionSetting(output.Settings, context)
            : undefined,
        Specialty: smithy_client_1.expectString(output.Specialty),
        StartTime: output.StartTime !== undefined && output.StartTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.StartTime)))
            : undefined,
        Tags: output.Tags !== undefined && output.Tags !== null
            ? deserializeAws_json1_1TagList(output.Tags, context)
            : undefined,
        Transcript: output.Transcript !== undefined && output.Transcript !== null
            ? deserializeAws_json1_1MedicalTranscript(output.Transcript, context)
            : undefined,
        TranscriptionJobStatus: smithy_client_1.expectString(output.TranscriptionJobStatus),
        Type: smithy_client_1.expectString(output.Type),
    };
};
const deserializeAws_json1_1MedicalTranscriptionJobSummaries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1MedicalTranscriptionJobSummary(entry, context);
    });
};
const deserializeAws_json1_1MedicalTranscriptionJobSummary = (output, context) => {
    return {
        CompletionTime: output.CompletionTime !== undefined && output.CompletionTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.CompletionTime)))
            : undefined,
        ContentIdentificationType: smithy_client_1.expectString(output.ContentIdentificationType),
        CreationTime: output.CreationTime !== undefined && output.CreationTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.CreationTime)))
            : undefined,
        FailureReason: smithy_client_1.expectString(output.FailureReason),
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        MedicalTranscriptionJobName: smithy_client_1.expectString(output.MedicalTranscriptionJobName),
        OutputLocationType: smithy_client_1.expectString(output.OutputLocationType),
        Specialty: smithy_client_1.expectString(output.Specialty),
        StartTime: output.StartTime !== undefined && output.StartTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.StartTime)))
            : undefined,
        TranscriptionJobStatus: smithy_client_1.expectString(output.TranscriptionJobStatus),
        Type: smithy_client_1.expectString(output.Type),
    };
};
const deserializeAws_json1_1MedicalTranscriptionSetting = (output, context) => {
    return {
        ChannelIdentification: smithy_client_1.expectBoolean(output.ChannelIdentification),
        MaxAlternatives: smithy_client_1.expectInt32(output.MaxAlternatives),
        MaxSpeakerLabels: smithy_client_1.expectInt32(output.MaxSpeakerLabels),
        ShowAlternatives: smithy_client_1.expectBoolean(output.ShowAlternatives),
        ShowSpeakerLabels: smithy_client_1.expectBoolean(output.ShowSpeakerLabels),
        VocabularyName: smithy_client_1.expectString(output.VocabularyName),
    };
};
const deserializeAws_json1_1Models = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1LanguageModel(entry, context);
    });
};
const deserializeAws_json1_1ModelSettings = (output, context) => {
    return {
        LanguageModelName: smithy_client_1.expectString(output.LanguageModelName),
    };
};
const deserializeAws_json1_1NonTalkTimeFilter = (output, context) => {
    return {
        AbsoluteTimeRange: output.AbsoluteTimeRange !== undefined && output.AbsoluteTimeRange !== null
            ? deserializeAws_json1_1AbsoluteTimeRange(output.AbsoluteTimeRange, context)
            : undefined,
        Negate: smithy_client_1.expectBoolean(output.Negate),
        RelativeTimeRange: output.RelativeTimeRange !== undefined && output.RelativeTimeRange !== null
            ? deserializeAws_json1_1RelativeTimeRange(output.RelativeTimeRange, context)
            : undefined,
        Threshold: smithy_client_1.expectLong(output.Threshold),
    };
};
const deserializeAws_json1_1NotFoundException = (output, context) => {
    return {
        Message: smithy_client_1.expectString(output.Message),
    };
};
const deserializeAws_json1_1RelativeTimeRange = (output, context) => {
    return {
        EndPercentage: smithy_client_1.expectInt32(output.EndPercentage),
        First: smithy_client_1.expectInt32(output.First),
        Last: smithy_client_1.expectInt32(output.Last),
        StartPercentage: smithy_client_1.expectInt32(output.StartPercentage),
    };
};
const deserializeAws_json1_1Rule = (output, context) => {
    if (output.InterruptionFilter !== undefined && output.InterruptionFilter !== null) {
        return {
            InterruptionFilter: deserializeAws_json1_1InterruptionFilter(output.InterruptionFilter, context),
        };
    }
    if (output.NonTalkTimeFilter !== undefined && output.NonTalkTimeFilter !== null) {
        return {
            NonTalkTimeFilter: deserializeAws_json1_1NonTalkTimeFilter(output.NonTalkTimeFilter, context),
        };
    }
    if (output.SentimentFilter !== undefined && output.SentimentFilter !== null) {
        return {
            SentimentFilter: deserializeAws_json1_1SentimentFilter(output.SentimentFilter, context),
        };
    }
    if (output.TranscriptFilter !== undefined && output.TranscriptFilter !== null) {
        return {
            TranscriptFilter: deserializeAws_json1_1TranscriptFilter(output.TranscriptFilter, context),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const deserializeAws_json1_1RuleList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Rule(smithy_client_1.expectUnion(entry), context);
    });
};
const deserializeAws_json1_1SentimentFilter = (output, context) => {
    return {
        AbsoluteTimeRange: output.AbsoluteTimeRange !== undefined && output.AbsoluteTimeRange !== null
            ? deserializeAws_json1_1AbsoluteTimeRange(output.AbsoluteTimeRange, context)
            : undefined,
        Negate: smithy_client_1.expectBoolean(output.Negate),
        ParticipantRole: smithy_client_1.expectString(output.ParticipantRole),
        RelativeTimeRange: output.RelativeTimeRange !== undefined && output.RelativeTimeRange !== null
            ? deserializeAws_json1_1RelativeTimeRange(output.RelativeTimeRange, context)
            : undefined,
        Sentiments: output.Sentiments !== undefined && output.Sentiments !== null
            ? deserializeAws_json1_1SentimentValueList(output.Sentiments, context)
            : undefined,
    };
};
const deserializeAws_json1_1SentimentValueList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return smithy_client_1.expectString(entry);
    });
};
const deserializeAws_json1_1Settings = (output, context) => {
    return {
        ChannelIdentification: smithy_client_1.expectBoolean(output.ChannelIdentification),
        MaxAlternatives: smithy_client_1.expectInt32(output.MaxAlternatives),
        MaxSpeakerLabels: smithy_client_1.expectInt32(output.MaxSpeakerLabels),
        ShowAlternatives: smithy_client_1.expectBoolean(output.ShowAlternatives),
        ShowSpeakerLabels: smithy_client_1.expectBoolean(output.ShowSpeakerLabels),
        VocabularyFilterMethod: smithy_client_1.expectString(output.VocabularyFilterMethod),
        VocabularyFilterName: smithy_client_1.expectString(output.VocabularyFilterName),
        VocabularyName: smithy_client_1.expectString(output.VocabularyName),
    };
};
const deserializeAws_json1_1StartCallAnalyticsJobResponse = (output, context) => {
    return {
        CallAnalyticsJob: output.CallAnalyticsJob !== undefined && output.CallAnalyticsJob !== null
            ? deserializeAws_json1_1CallAnalyticsJob(output.CallAnalyticsJob, context)
            : undefined,
    };
};
const deserializeAws_json1_1StartMedicalTranscriptionJobResponse = (output, context) => {
    return {
        MedicalTranscriptionJob: output.MedicalTranscriptionJob !== undefined && output.MedicalTranscriptionJob !== null
            ? deserializeAws_json1_1MedicalTranscriptionJob(output.MedicalTranscriptionJob, context)
            : undefined,
    };
};
const deserializeAws_json1_1StartTranscriptionJobResponse = (output, context) => {
    return {
        TranscriptionJob: output.TranscriptionJob !== undefined && output.TranscriptionJob !== null
            ? deserializeAws_json1_1TranscriptionJob(output.TranscriptionJob, context)
            : undefined,
    };
};
const deserializeAws_json1_1StringTargetList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return smithy_client_1.expectString(entry);
    });
};
const deserializeAws_json1_1SubtitleFileUris = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return smithy_client_1.expectString(entry);
    });
};
const deserializeAws_json1_1SubtitleFormats = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return smithy_client_1.expectString(entry);
    });
};
const deserializeAws_json1_1SubtitlesOutput = (output, context) => {
    return {
        Formats: output.Formats !== undefined && output.Formats !== null
            ? deserializeAws_json1_1SubtitleFormats(output.Formats, context)
            : undefined,
        SubtitleFileUris: output.SubtitleFileUris !== undefined && output.SubtitleFileUris !== null
            ? deserializeAws_json1_1SubtitleFileUris(output.SubtitleFileUris, context)
            : undefined,
    };
};
const deserializeAws_json1_1Tag = (output, context) => {
    return {
        Key: smithy_client_1.expectString(output.Key),
        Value: smithy_client_1.expectString(output.Value),
    };
};
const deserializeAws_json1_1TagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Tag(entry, context);
    });
};
const deserializeAws_json1_1TagResourceResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1Transcript = (output, context) => {
    return {
        RedactedTranscriptFileUri: smithy_client_1.expectString(output.RedactedTranscriptFileUri),
        TranscriptFileUri: smithy_client_1.expectString(output.TranscriptFileUri),
    };
};
const deserializeAws_json1_1TranscriptFilter = (output, context) => {
    return {
        AbsoluteTimeRange: output.AbsoluteTimeRange !== undefined && output.AbsoluteTimeRange !== null
            ? deserializeAws_json1_1AbsoluteTimeRange(output.AbsoluteTimeRange, context)
            : undefined,
        Negate: smithy_client_1.expectBoolean(output.Negate),
        ParticipantRole: smithy_client_1.expectString(output.ParticipantRole),
        RelativeTimeRange: output.RelativeTimeRange !== undefined && output.RelativeTimeRange !== null
            ? deserializeAws_json1_1RelativeTimeRange(output.RelativeTimeRange, context)
            : undefined,
        Targets: output.Targets !== undefined && output.Targets !== null
            ? deserializeAws_json1_1StringTargetList(output.Targets, context)
            : undefined,
        TranscriptFilterType: smithy_client_1.expectString(output.TranscriptFilterType),
    };
};
const deserializeAws_json1_1TranscriptionJob = (output, context) => {
    return {
        CompletionTime: output.CompletionTime !== undefined && output.CompletionTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.CompletionTime)))
            : undefined,
        ContentRedaction: output.ContentRedaction !== undefined && output.ContentRedaction !== null
            ? deserializeAws_json1_1ContentRedaction(output.ContentRedaction, context)
            : undefined,
        CreationTime: output.CreationTime !== undefined && output.CreationTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.CreationTime)))
            : undefined,
        FailureReason: smithy_client_1.expectString(output.FailureReason),
        IdentifiedLanguageScore: smithy_client_1.limitedParseFloat32(output.IdentifiedLanguageScore),
        IdentifyLanguage: smithy_client_1.expectBoolean(output.IdentifyLanguage),
        JobExecutionSettings: output.JobExecutionSettings !== undefined && output.JobExecutionSettings !== null
            ? deserializeAws_json1_1JobExecutionSettings(output.JobExecutionSettings, context)
            : undefined,
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        LanguageOptions: output.LanguageOptions !== undefined && output.LanguageOptions !== null
            ? deserializeAws_json1_1LanguageOptions(output.LanguageOptions, context)
            : undefined,
        Media: output.Media !== undefined && output.Media !== null
            ? deserializeAws_json1_1Media(output.Media, context)
            : undefined,
        MediaFormat: smithy_client_1.expectString(output.MediaFormat),
        MediaSampleRateHertz: smithy_client_1.expectInt32(output.MediaSampleRateHertz),
        ModelSettings: output.ModelSettings !== undefined && output.ModelSettings !== null
            ? deserializeAws_json1_1ModelSettings(output.ModelSettings, context)
            : undefined,
        Settings: output.Settings !== undefined && output.Settings !== null
            ? deserializeAws_json1_1Settings(output.Settings, context)
            : undefined,
        StartTime: output.StartTime !== undefined && output.StartTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.StartTime)))
            : undefined,
        Subtitles: output.Subtitles !== undefined && output.Subtitles !== null
            ? deserializeAws_json1_1SubtitlesOutput(output.Subtitles, context)
            : undefined,
        Tags: output.Tags !== undefined && output.Tags !== null
            ? deserializeAws_json1_1TagList(output.Tags, context)
            : undefined,
        Transcript: output.Transcript !== undefined && output.Transcript !== null
            ? deserializeAws_json1_1Transcript(output.Transcript, context)
            : undefined,
        TranscriptionJobName: smithy_client_1.expectString(output.TranscriptionJobName),
        TranscriptionJobStatus: smithy_client_1.expectString(output.TranscriptionJobStatus),
    };
};
const deserializeAws_json1_1TranscriptionJobSummaries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1TranscriptionJobSummary(entry, context);
    });
};
const deserializeAws_json1_1TranscriptionJobSummary = (output, context) => {
    return {
        CompletionTime: output.CompletionTime !== undefined && output.CompletionTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.CompletionTime)))
            : undefined,
        ContentRedaction: output.ContentRedaction !== undefined && output.ContentRedaction !== null
            ? deserializeAws_json1_1ContentRedaction(output.ContentRedaction, context)
            : undefined,
        CreationTime: output.CreationTime !== undefined && output.CreationTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.CreationTime)))
            : undefined,
        FailureReason: smithy_client_1.expectString(output.FailureReason),
        IdentifiedLanguageScore: smithy_client_1.limitedParseFloat32(output.IdentifiedLanguageScore),
        IdentifyLanguage: smithy_client_1.expectBoolean(output.IdentifyLanguage),
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        ModelSettings: output.ModelSettings !== undefined && output.ModelSettings !== null
            ? deserializeAws_json1_1ModelSettings(output.ModelSettings, context)
            : undefined,
        OutputLocationType: smithy_client_1.expectString(output.OutputLocationType),
        StartTime: output.StartTime !== undefined && output.StartTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.StartTime)))
            : undefined,
        TranscriptionJobName: smithy_client_1.expectString(output.TranscriptionJobName),
        TranscriptionJobStatus: smithy_client_1.expectString(output.TranscriptionJobStatus),
    };
};
const deserializeAws_json1_1UntagResourceResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1UpdateCallAnalyticsCategoryResponse = (output, context) => {
    return {
        CategoryProperties: output.CategoryProperties !== undefined && output.CategoryProperties !== null
            ? deserializeAws_json1_1CategoryProperties(output.CategoryProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1UpdateMedicalVocabularyResponse = (output, context) => {
    return {
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        LastModifiedTime: output.LastModifiedTime !== undefined && output.LastModifiedTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.LastModifiedTime)))
            : undefined,
        VocabularyName: smithy_client_1.expectString(output.VocabularyName),
        VocabularyState: smithy_client_1.expectString(output.VocabularyState),
    };
};
const deserializeAws_json1_1UpdateVocabularyFilterResponse = (output, context) => {
    return {
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        LastModifiedTime: output.LastModifiedTime !== undefined && output.LastModifiedTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.LastModifiedTime)))
            : undefined,
        VocabularyFilterName: smithy_client_1.expectString(output.VocabularyFilterName),
    };
};
const deserializeAws_json1_1UpdateVocabularyResponse = (output, context) => {
    return {
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        LastModifiedTime: output.LastModifiedTime !== undefined && output.LastModifiedTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.LastModifiedTime)))
            : undefined,
        VocabularyName: smithy_client_1.expectString(output.VocabularyName),
        VocabularyState: smithy_client_1.expectString(output.VocabularyState),
    };
};
const deserializeAws_json1_1Vocabularies = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1VocabularyInfo(entry, context);
    });
};
const deserializeAws_json1_1VocabularyFilterInfo = (output, context) => {
    return {
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        LastModifiedTime: output.LastModifiedTime !== undefined && output.LastModifiedTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.LastModifiedTime)))
            : undefined,
        VocabularyFilterName: smithy_client_1.expectString(output.VocabularyFilterName),
    };
};
const deserializeAws_json1_1VocabularyFilters = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1VocabularyFilterInfo(entry, context);
    });
};
const deserializeAws_json1_1VocabularyInfo = (output, context) => {
    return {
        LanguageCode: smithy_client_1.expectString(output.LanguageCode),
        LastModifiedTime: output.LastModifiedTime !== undefined && output.LastModifiedTime !== null
            ? smithy_client_1.expectNonNull(smithy_client_1.parseEpochTimestamp(smithy_client_1.expectNumber(output.LastModifiedTime)))
            : undefined,
        VocabularyName: smithy_client_1.expectString(output.VocabularyName),
        VocabularyState: smithy_client_1.expectString(output.VocabularyState),
    };
};
const deserializeMetadata = (output) => {
    var _a;
    return ({
        httpStatusCode: output.statusCode,
        requestId: (_a = output.headers["x-amzn-requestid"]) !== null && _a !== void 0 ? _a : output.headers["x-amzn-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });
};
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
    return "";
};
